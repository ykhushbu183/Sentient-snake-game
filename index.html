<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sentient Snake</title>
  <style>
    html,body { height:100%; margin:0; font-family: Inter, system-ui, sans-serif; background:#071021; color:#fff; }
    /* big faded background text */
    .bg-text {
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index:0;
    }
    .bg-text h1 {
      font-size:18vw;
      margin:0;
      line-height:0.8;
      color:rgba(255,255,255,0.03);
      letter-spacing:0.1em;
      transform:rotate(-8deg);
      user-select:none;
    }

    /* canvas container */
    #wrap { position:relative; width:100vw; height:100vh; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; z-index:1; background:transparent; }

    /* HUD */
    #score {
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      z-index:3;
      font-size:20px;
      background: rgba(0,0,0,0.35);
      padding:8px 14px;
      border-radius:8px;
      color:#fff;
      letter-spacing:0.02em;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    }

    /* footer with X handle */
    #footer {
      position:fixed;
      right:12px;
      bottom:12px;
      z-index:3;
      font-size:14px;
      color:#ddd;
    }
    #footer a { color:#1DA1F2; text-decoration:none; font-weight:600; }

    /* overlay Game Over */
    #overlay {
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:4;
      background: rgba(0,0,0,0.55);
      color:#fff;
      font-size:22px;
      flex-direction:column;
      gap:12px;
      visibility:hidden;
    }
    #overlay.show { visibility:visible; }
    .btn {
      background:#1DA1F2;
      color:#fff;
      padding:8px 14px;
      border-radius:8px;
      border:0;
      cursor:pointer;
      font-weight:600;
    }

    /* small instructions top-left */
    #hint {
      position:fixed;
      left:12px;
      top:12px;
      z-index:3;
      font-size:13px;
      color:#cfd8dc;
      background:rgba(0,0,0,0.25);
      padding:6px 10px;
      border-radius:8px;
    }

    @media (max-width:600px){
      .bg-text h1 { font-size:32vw; }
      #score { font-size:16px; bottom:12px; }
    }
  </style>
</head>
<body>
  <div class="bg-text"><h1>SENTIENT</h1></div>

  <div id="wrap">
    <canvas id="game"></canvas>
  </div>

  <div id="hint">Arrows / WASD to move â€¢ Space to pause</div>

  <div id="score">Score: 0</div>

  <div id="footer">
    made by <a href="https://x.com/sonuwork37" target="_blank" rel="noopener noreferrer">@sonuwork37</a>
  </div>

  <div id="overlay">
    <div style="font-size:36px;font-weight:700;">Game Over</div>
    <div id="finalScore">Score: 0</div>
    <button id="restartBtn" class="btn">Restart</button>
  </div>

  <script>
  /*
    Simple grid-based Snake.
    - Each food = +10 points
    - self-collision => Game Over
    - edges wrap around (so snake can grow indefinitely)
    - to use custom sentient logo for food: put sentient-logo.png in repo root and set useLogoForFood = true
  */

  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const finalScoreEl = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');

    // settings
    let cellSize = 20;              // pixel size per cell
    let speedMs = 100;             // tick ms (lower => faster)
    let useLogoForFood = false;    // set true if you add sentient-logo.png to repo root
    let foodImg = null;

    // dynamic state
    let cols, rows;
    let snake = [];
    let dir = {x:1, y:0};
    let nextDir = {x:1, y:0};
    let food = null;
    let score = 0;
    let tickHandle = null;
    let running = true;

    function resizeAndInit(){
      // adapt cell size on small screens
      if(window.innerWidth < 500) cellSize = 14;
      else cellSize = 20;

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cols = Math.floor(canvas.width / cellSize);
      rows = Math.floor((canvas.height - 120) / cellSize); // leave space (just in case)

      resetGame();
    }

    function resetGame(){
      // initialize snake in center
      snake = [];
      const startLen = 5;
      const cx = Math.floor(cols/2);
      const cy = Math.floor(rows/2);
      for(let i=0;i<startLen;i++){
        snake.push({x: cx - i, y: cy});
      }
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      score = 0;
      updateScore();
      spawnFood();
      running = true;
      overlay.classList.remove('show');
      if(tickHandle) clearInterval(tickHandle);
      tickHandle = setInterval(tick, speedMs);
    }

    function spawnFood(){
      let tries = 0;
      while(true){
        const fx = Math.floor(Math.random()*cols);
        const fy = Math.floor(Math.random()*rows);
        const collision = snake.some(s => s.x === fx && s.y === fy);
        if(!collision){
          food = {x:fx, y:fy};
          break;
        }
        if(++tries > 2000) { food = {x:0,y:0}; break; }
      }
    }

    function updateScore(){
      scoreEl.textContent = "Score: " + score;
    }

    function tick(){
      // apply direction (prevent immediate reverse)
      if((nextDir.x === -dir.x && nextDir.y === -dir.y) ) {
        // ignore reversing
      } else {
        dir = nextDir;
      }

      const head = { x: (snake[0].x + dir.x + cols) % cols, y: (snake[0].y + dir.y + rows) % rows };

      // self collision?
      if(snake.some(s => s.x === head.x && s.y === head.y)){
        gameOver();
        return;
      }

      snake.unshift(head);

      // eat food?
      if(head.x === food.x && head.y === food.y){
        score += 10;
        updateScore();
        spawnFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // draw food
      const fx = food.x * cellSize + 1;
      const fy = food.y * cellSize + 1;
      const fsz = cellSize - 2;

      if(useLogoForFood && foodImg && foodImg.complete){
        // draw image centered in the cell
        ctx.drawImage(foodImg, fx, fy, fsz, fsz);
      } else {
        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath();
        ctx.arc(fx + fsz/2, fy + fsz/2, Math.max(3, fsz/2 - 1), 0, Math.PI*2);
        ctx.fill();
      }

      // draw snake
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        const x = s.x * cellSize + 1;
        const y = s.y * cellSize + 1;
        const w = cellSize - 2;
        const h = cellSize - 2;
        if(i===0){
          // head
          ctx.fillStyle = "#00d1b2";
        } else {
          // body gradient
          ctx.fillStyle = `hsl(${120 - Math.min(100, i*2)}, 60%, ${30 + Math.min(30, i*0.4)}%)`;
        }
        ctx.fillRect(x,y,w,h);
      }
    }

    function gameOver(){
      running = false;
      clearInterval(tickHandle);
      finalScoreEl.textContent = "Score: " + score;
      overlay.classList.add('show');
    }

    // controls
    window.addEventListener('keydown', (e) => {
      if(!running) return;
      if(e.key === 'ArrowUp' || e.key === 'w') nextDir = {x:0,y:-1};
      if(e.key === 'ArrowDown' || e.key === 's') nextDir = {x:0,y:1};
      if(e.key === 'ArrowLeft' || e.key === 'a') nextDir = {x:-1,y:0};
      if(e.key === 'ArrowRight' || e.key === 'd') nextDir = {x:1,y:0};
      if(e.key === ' '){ // pause
        if(tickHandle) { clearInterval(tickHandle); tickHandle = null; running = false; }
        else { tickHandle = setInterval(tick, speedMs); running = true; }
      }
    });

    restartBtn.addEventListener('click', () => {
      resetGame();
    });

    // load optional food image if present
    (function tryLoadFoodImage(){
      if(!useLogoForFood) return;
      const img = new Image();
      img.src = "/sentient-logo.png";
      img.onload = () => { foodImg = img; };
      img.onerror = () => { foodImg = null; };
    })();

    // resizing
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        // re-compute grid and reset so layout fits
        resizeAndInit();
      }, 150);
    });

    // start
    resizeAndInit();

    // initial draw while waiting
    draw();

  })();
  </script>
</body>
</html>
